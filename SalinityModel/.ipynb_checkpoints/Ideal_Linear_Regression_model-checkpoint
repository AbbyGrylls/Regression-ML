{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "be3071b3-62d8-4e28-a31a-493fce00b77c",
   "metadata": {},
   "source": [
    "# [IMPOROVED] IDEAL LINEAR REGRESSION: COST IS NOW ZERO\n",
    "## Problem Statement:\n",
    "   The cost function value is about 550 in our previous model(SalinityModel.py) where we assumed the data is linearly related. To imporvise this by bringing J value or cost value to zero, we take nonlinear functions such as f_wb_x= w1x+w2x^2+w3x^3+b and recompute the correct weights and bias.\n",
    "## Solution Approach:\n",
    "1. Approach is same as before, just the function will be different and so its derivatives to calculate gradient descent.\n",
    "2. The weight matrix is not column anymore. It would be, rows- weights for each feature, columns- weight matrix for each coefficient of x, x^2...\n",
    "3. Updated f(x) is ![Non Linear function](NewFofX.png)\n",
    "4. Updated derivates: Derivative wrt w1: x .\n",
    "5. Derivative wrt w2: 2*(w2路x)*x\n",
    "6. Derivative wrt w3: 3*(w3路x)^2*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0a06ef5b-042d-4b0f-b086-6ea50ba28bea",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Importing required libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f4f45e2-1181-4108-8aa9-b2f5e575f2c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load, Structure and Normalize data\n",
    "df = pd.read_csv('bottle.csv', low_memory=False)\n",
    "Temperature = df['T_degC'].to_numpy()[:1215]\n",
    "Depth = df['Depthm'].to_numpy()[:1215]\n",
    "Oxygen = df['O2ml_L'].to_numpy()[:1215]\n",
    "Density = df['STheta'].to_numpy()[:1215]\n",
    "Salinity = df['Salnty'].to_numpy()[:1215]\n",
    "varX=np.column_stack([Temperature, Depth, Density]) # didn't add oxygen level because data inavailability\n",
    "means = varX.mean(axis=0)\n",
    "stds = varX.std(axis=0)\n",
    "varX = (varX - means) / stds\n",
    "varY=Salinity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3a0b5b91-a8b1-4cb5-8184-aa46b5c6e484",
   "metadata": {},
   "outputs": [],
   "source": [
    "# computing function value to find error from each training example and predicted value\n",
    "def compute_func(x, w, n, b):\n",
    "    \"\"\"\n",
    "    x: input feature vector (num_features,)\n",
    "    w: weight matrix (num_features, n)\n",
    "    n: highest power (degree)\n",
    "    b: bias\n",
    "    \"\"\"\n",
    "    result = 0\n",
    "    for power in range(1,n + 1):\n",
    "        result += np.dot(x, w[:, power - 1]) ** power\n",
    "    result += b\n",
    "    return result  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb2f8dcd-cb09-42c3-b74a-0f8d03642a1d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# computing cost first:\n",
    "def compute_cost(varX,varY,w1,w2,w3,b,m,lmda,n):\n",
    "    cost = 0\n",
    "    # stacking w1, w2, w3 into a weight matrix of shape (num_features, n)\n",
    "    w = np.column_stack([w1, w2, w3])\n",
    "    for i in range(m):\n",
    "        f_wb_i = compute_func(varX[i], w, n, b)\n",
    "        cost += (f_wb_i - varY[i]) ** 2\n",
    "    cost = cost / (2 * m)\n",
    "    # regularization (excluding bias)\n",
    "    cost += (lmda / (2 * m)) * (np.sum(w1 ** 2) + np.sum(w2 ** 2) + np.sum(w3 ** 2))\n",
    "    return cost"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f70d0a38-8ba0-4a91-bcee-7a89e0002445",
   "metadata": {},
   "outputs": [],
   "source": [
    "# computing gradient function:\n",
    "def compute_grad(varX,varY,w1,w2,w3,b,m,lmda,n):\n",
    "    \"\"\"\n",
    "    Computes gradients for w1, w2, w3, and b for the given cost function.\n",
    "    Returns: dw1, dw2, dw3, db (all shapes match their respective weights)\n",
    "    \"\"\"\n",
    "    num_features = varX.shape[1]\n",
    "    dw1 = np.zeros(num_features)\n",
    "    dw2 = np.zeros(num_features)\n",
    "    dw3 = np.zeros(num_features)\n",
    "    db = 0\n",
    "    # Stack weights for use in compute_func\n",
    "    w = np.column_stack([w1, w2, w3])\n",
    "    for i in range(m):\n",
    "        x = varX[i]\n",
    "        y = varY[i]\n",
    "        f_wb_i = compute_func(x, w, n, b)\n",
    "        err = f_wb_i - y\n",
    "        dw1 += err * (np.dot(x, w[:, 0]) ** 0) * x  # derivative wrt w1: x\n",
    "        dw2 += err * 2 * (np.dot(x, w[:, 1])) * x   # derivative wrt w2: 2*(w2路x)*x\n",
    "        dw3 += err * 3 * (np.dot(x, w[:, 2]) ** 2) * x  # derivative wrt w3: 3*(w3路x)^2*x\n",
    "        db += err\n",
    "    dw1 = dw1 / m + (lmda / m) * w1\n",
    "    dw2 = dw2 / m + (lmda / m) * w2\n",
    "    dw3 = dw3 / m + (lmda / m) * w3\n",
    "    db = db / m\n",
    "    return dw1, dw2, dw3, db"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f985470b-0b5e-49ea-91f4-514f83d4d61a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# computing gradient descent:\n",
    "def gradient_descent(varX, varY, w1, w2, w3, b, m, lmda, n, alpha, num_iters):\n",
    "    \"\"\"\n",
    "    Performs gradient descent to optimize w1, w2, w3, and b.\n",
    "    Returns: w1, w2, w3, b, cost_history (list)\n",
    "    \"\"\"\n",
    "    cost_history = []\n",
    "    for i in range(num_iters):\n",
    "        dw1, dw2, dw3, db = compute_grad(varX, varY, w1, w2, w3, b, m, lmda, n)\n",
    "        w1 = w1 - alpha * dw1\n",
    "        w2 = w2 - alpha * dw2\n",
    "        w3 = w3 - alpha * dw3\n",
    "        b = b - alpha * db\n",
    "        if i % 10 == 0 or i == num_iters - 1:\n",
    "            cost = compute_cost(varX, varY, w1, w2, w3, b, m, lmda, n)\n",
    "            cost_history.append(cost)\n",
    "    return w1, w2, w3, b, cost_history\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d11a9e14-b155-4b8f-a164-0ee7d9fba524",
   "metadata": {},
   "outputs": [],
   "source": [
    "# init parameters\n",
    "num_features = varX.shape[1]\n",
    "w1 = np.zeros(num_features)\n",
    "w2 = np.zeros(num_features)\n",
    "w3 = np.zeros(num_features)\n",
    "b = 0\n",
    "m = varX.shape[0]\n",
    "n = 3\n",
    "lmda = 0.01 \n",
    "alpha = 0.01 \n",
    "num_iters = 500\n",
    "w1, w2, w3, b, cost_history = gradient_descent(varX, varY, w1, w2, w3, b, m, lmda, n, alpha, num_iters)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c0ba39d5-d5f1-4312-a97c-1080232afa02",
   "metadata": {},
   "outputs": [],
   "source": [
    "# plotting cost value reduction over iterations and Predicted Salinity Values vs Actual Values\n",
    "plt.figure(1)\n",
    "plt.plot(np.arange(0, len(cost_history)*10, 10), cost_history)\n",
    "plt.xlabel('Iteration')\n",
    "plt.ylabel('Cost')\n",
    "plt.title('Cost reduction over iterations')\n",
    "\n",
    "preds = []\n",
    "w = np.column_stack([w1, w2, w3])\n",
    "for i in range(m):\n",
    "    preds.append(compute_func(varX[i], w, n, b))\n",
    "preds = np.array(preds)\n",
    "\n",
    "plt.figure(2)\n",
    "plt.scatter(varY, preds, alpha=0.5)\n",
    "plt.xlabel('Actual Salinity')\n",
    "plt.ylabel('Predicted Salinity')\n",
    "plt.title('Actual vs Predicted Salinity')\n",
    "plt.plot([varY.min(), varY.max()], [varY.min(), varY.max()], 'r--')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a78983d-2f1d-486a-b9f7-9265c81646f6",
   "metadata": {},
   "source": [
    "The correct plots should be like this:\n",
    "fig 1: ![Cost Reduction over Iterations](Fig1.png)\n",
    "fig 2: ![Actual vs Predicted Salinity Plot](Fig2.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68e5e754-c2d7-4508-a5ab-806054a4ffe0",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
